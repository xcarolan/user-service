// Code generated by MockGen. DO NOT EDIT.
// Source: internal/database/database.go

package mocks

import (
	context "context"
	pgconn "github.com/jackc/pgconn"
	pgx "github.com/jackc/pgx/v4" // Import pgx directly
	mock "github.com/stretchr/testify/mock"
)

// MockDBTX is a mock of DBTX interface.
type MockDBTX struct {
	mock.Mock
}

// Exec mocks base method.
func (m *MockDBTX) Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error) {
	allArgs := make([]interface{}, 0, 2+len(arguments))
	allArgs = append(allArgs, ctx, sql)
	allArgs = append(allArgs, arguments...)
	ret := m.Called(allArgs...)
	return ret.Get(0).(pgconn.CommandTag), ret.Error(1)
}

// Query mocks base method.
func (m *MockDBTX) Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error) {
	allArgs := make([]interface{}, 0, 2+len(args))
	allArgs = append(allArgs, ctx, sql)
	allArgs = append(allArgs, args...)
	ret := m.Called(allArgs...)
	var r0 pgx.Rows
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(*MockRows)
	}
	return r0, ret.Error(1)
}

// QueryRow mocks base method.
func (m *MockDBTX) QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row {
	allArgs := make([]interface{}, 0, 2+len(args))
	allArgs = append(allArgs, ctx, sql)
	allArgs = append(allArgs, args...)
	ret := m.Called(allArgs...)
	var r0 pgx.Row
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) pgx.Row); ok {
		return rf(ctx, sql, args...)
	}
	if ret.Get(0) != nil {
		r0 = ret.Get(0).(pgx.Row)
	}
	return r0
}
